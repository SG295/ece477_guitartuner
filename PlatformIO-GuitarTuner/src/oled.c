//===========================================================================
// oled.c: Adapted from 362's "lcd.c" helper function as well as...
//===========================================================================

#include "oled.h"

void nano_wait(int t); // FROM ECE362 LABS

oled_dev_t oleddev; 

const uint16_t arrow[7]={
    0x0000,
    0x0000,
    0x0010,
    0x0018,
    0x001C,
    0x1FFE,
    0x1FFF
};

const unsigned char asc2_1206[95][12]={
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x04,0x00,0x00},/*"!",1*/
{0x00,0x14,0x0A,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
{0x00,0x00,0x14,0x14,0x3F,0x14,0x0A,0x3F,0x0A,0x0A,0x00,0x00},/*"#",3*/
{0x00,0x04,0x1E,0x15,0x05,0x06,0x0C,0x14,0x15,0x0F,0x04,0x00},/*"$",4*/
{0x00,0x00,0x12,0x15,0x0D,0x0A,0x14,0x2C,0x2A,0x12,0x00,0x00},/*"%",5*/
{0x00,0x00,0x04,0x0A,0x0A,0x1E,0x15,0x15,0x09,0x36,0x00,0x00},/*"&",6*/
{0x00,0x02,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x20,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x20,0x00},/*"(",8*/
{0x00,0x02,0x04,0x08,0x08,0x08,0x08,0x08,0x08,0x04,0x02,0x00},/*")",9*/
{0x00,0x00,0x00,0x04,0x15,0x0E,0x0E,0x15,0x04,0x00,0x00,0x00},/*"*",10*/
{0x00,0x00,0x04,0x04,0x04,0x1F,0x04,0x04,0x04,0x00,0x00,0x00},/*"+",11*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x01},/*",",12*/
{0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00},/*"-",13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00},/*".",14*/
{0x00,0x10,0x08,0x08,0x08,0x04,0x04,0x02,0x02,0x02,0x01,0x00},/*"/",15*/
{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x0E,0x00,0x00},/*"0",16*/
{0x00,0x00,0x04,0x06,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/*"1",17*/
{0x00,0x00,0x0E,0x11,0x11,0x08,0x04,0x02,0x01,0x1F,0x00,0x00},/*"2",18*/
{0x00,0x00,0x0E,0x11,0x10,0x0C,0x10,0x10,0x11,0x0E,0x00,0x00},/*"3",19*/
{0x00,0x00,0x08,0x0C,0x0A,0x0A,0x09,0x1E,0x08,0x18,0x00,0x00},/*"4",20*/
{0x00,0x00,0x1F,0x01,0x01,0x0F,0x10,0x10,0x11,0x0E,0x00,0x00},/*"5",21*/
{0x00,0x00,0x0E,0x09,0x01,0x0F,0x11,0x11,0x11,0x0E,0x00,0x00},/*"6",22*/
{0x00,0x00,0x1F,0x09,0x08,0x04,0x04,0x04,0x04,0x04,0x00,0x00},/*"7",23*/
{0x00,0x00,0x0E,0x11,0x11,0x0E,0x11,0x11,0x11,0x0E,0x00,0x00},/*"8",24*/
{0x00,0x00,0x0E,0x11,0x11,0x11,0x1E,0x10,0x12,0x0E,0x00,0x00},/*"9",25*/
{0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x04,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x04,0x00},/*";",27*/
{0x00,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x00,0x00},/*"<",28*/
{0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x1F,0x00,0x00,0x00,0x00},/*"=",29*/
{0x00,0x02,0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x02,0x00,0x00},/*">",30*/
{0x00,0x00,0x0E,0x11,0x11,0x08,0x04,0x04,0x00,0x04,0x00,0x00},/*"?",31*/
{0x00,0x00,0x0E,0x11,0x19,0x15,0x15,0x1D,0x01,0x1E,0x00,0x00},/*"@",32*/
{0x00,0x00,0x04,0x04,0x0C,0x0A,0x0A,0x1E,0x12,0x33,0x00,0x00},/*"A",33*/
{0x00,0x00,0x0F,0x12,0x12,0x0E,0x12,0x12,0x12,0x0F,0x00,0x00},/*"B",34*/
{0x00,0x00,0x1E,0x11,0x01,0x01,0x01,0x01,0x11,0x0E,0x00,0x00},/*"C",35*/
{0x00,0x00,0x0F,0x12,0x12,0x12,0x12,0x12,0x12,0x0F,0x00,0x00},/*"D",36*/
{0x00,0x00,0x1F,0x12,0x0A,0x0E,0x0A,0x02,0x12,0x1F,0x00,0x00},/*"E",37*/
{0x00,0x00,0x1F,0x12,0x0A,0x0E,0x0A,0x02,0x02,0x07,0x00,0x00},/*"F",38*/
{0x00,0x00,0x1C,0x12,0x01,0x01,0x39,0x11,0x12,0x0C,0x00,0x00},/*"G",39*/
{0x00,0x00,0x33,0x12,0x12,0x1E,0x12,0x12,0x12,0x33,0x00,0x00},/*"H",40*/
{0x00,0x00,0x1F,0x04,0x04,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/*"I",41*/
{0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x09,0x07,0x00},/*"J",42*/
{0x00,0x00,0x37,0x12,0x0A,0x06,0x0A,0x0A,0x12,0x37,0x00,0x00},/*"K",43*/
{0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x22,0x3F,0x00,0x00},/*"L",44*/
{0x00,0x00,0x1B,0x1B,0x1B,0x1B,0x15,0x15,0x15,0x15,0x00,0x00},/*"M",45*/
{0x00,0x00,0x3B,0x12,0x16,0x16,0x1A,0x1A,0x12,0x17,0x00,0x00},/*"N",46*/
{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x11,0x11,0x0E,0x00,0x00},/*"O",47*/
{0x00,0x00,0x0F,0x12,0x12,0x0E,0x02,0x02,0x02,0x07,0x00,0x00},/*"P",48*/
{0x00,0x00,0x0E,0x11,0x11,0x11,0x11,0x17,0x19,0x0E,0x18,0x00},/*"Q",49*/
{0x00,0x00,0x0F,0x12,0x12,0x0E,0x0A,0x12,0x12,0x37,0x00,0x00},/*"R",50*/
{0x00,0x00,0x1E,0x11,0x01,0x06,0x08,0x10,0x11,0x0F,0x00,0x00},/*"S",51*/
{0x00,0x00,0x1F,0x15,0x04,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/*"T",52*/
{0x00,0x00,0x33,0x12,0x12,0x12,0x12,0x12,0x12,0x0C,0x00,0x00},/*"U",53*/
{0x00,0x00,0x33,0x12,0x12,0x0A,0x0A,0x0C,0x04,0x04,0x00,0x00},/*"V",54*/
{0x00,0x00,0x15,0x15,0x15,0x0E,0x0A,0x0A,0x0A,0x0A,0x00,0x00},/*"W",55*/
{0x00,0x00,0x1B,0x0A,0x0A,0x04,0x04,0x0A,0x0A,0x1B,0x00,0x00},/*"X",56*/
{0x00,0x00,0x1B,0x0A,0x0A,0x04,0x04,0x04,0x04,0x0E,0x00,0x00},/*"Y",57*/
{0x00,0x00,0x1F,0x09,0x08,0x04,0x04,0x02,0x12,0x1F,0x00,0x00},/*"Z",58*/
{0x00,0x1C,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x1C,0x00},/*"[",59*/
{0x00,0x02,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x00,0x00},/*"\",60*/
{0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0E,0x00},/*"]",61*/
{0x00,0x04,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F},/*"_",63*/
{0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x1C,0x12,0x3C,0x00,0x00},/*"a",65*/
{0x00,0x00,0x03,0x02,0x02,0x0E,0x12,0x12,0x12,0x0E,0x00,0x00},/*"b",66*/
{0x00,0x00,0x00,0x00,0x00,0x1C,0x12,0x02,0x02,0x1C,0x00,0x00},/*"c",67*/
{0x00,0x00,0x18,0x10,0x10,0x1C,0x12,0x12,0x12,0x3C,0x00,0x00},/*"d",68*/
{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x1E,0x02,0x1C,0x00,0x00},/*"e",69*/
{0x00,0x00,0x38,0x04,0x04,0x1E,0x04,0x04,0x04,0x1E,0x00,0x00},/*"f",70*/
{0x00,0x00,0x00,0x00,0x00,0x3C,0x12,0x0C,0x02,0x1E,0x22,0x1C},/*"g",71*/
{0x00,0x00,0x03,0x02,0x02,0x0E,0x12,0x12,0x12,0x37,0x00,0x00},/*"h",72*/
{0x00,0x00,0x04,0x00,0x00,0x06,0x04,0x04,0x04,0x0E,0x00,0x00},/*"i",73*/
{0x00,0x00,0x08,0x00,0x00,0x0C,0x08,0x08,0x08,0x08,0x08,0x07},/*"j",74*/
{0x00,0x00,0x03,0x02,0x02,0x3A,0x0A,0x0E,0x12,0x37,0x00,0x00},/*"k",75*/
{0x00,0x00,0x07,0x04,0x04,0x04,0x04,0x04,0x04,0x1F,0x00,0x00},/*"l",76*/
{0x00,0x00,0x00,0x00,0x00,0x0F,0x15,0x15,0x15,0x15,0x00,0x00},/*"m",77*/
{0x00,0x00,0x00,0x00,0x00,0x0F,0x12,0x12,0x12,0x37,0x00,0x00},/*"n",78*/
{0x00,0x00,0x00,0x00,0x00,0x0C,0x12,0x12,0x12,0x0C,0x00,0x00},/*"o",79*/
{0x00,0x00,0x00,0x00,0x00,0x0F,0x12,0x12,0x12,0x0E,0x02,0x07},/*"p",80*/
{0x00,0x00,0x00,0x00,0x00,0x1C,0x12,0x12,0x12,0x1C,0x10,0x38},/*"q",81*/
{0x00,0x00,0x00,0x00,0x00,0x1B,0x06,0x02,0x02,0x07,0x00,0x00},/*"r",82*/
{0x00,0x00,0x00,0x00,0x00,0x1E,0x02,0x0C,0x10,0x1E,0x00,0x00},/*"s",83*/
{0x00,0x00,0x00,0x04,0x04,0x0E,0x04,0x04,0x04,0x18,0x00,0x00},/*"t",84*/
{0x00,0x00,0x00,0x00,0x00,0x1B,0x12,0x12,0x12,0x3C,0x00,0x00},/*"u",85*/
{0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0A,0x0C,0x04,0x00,0x00},/*"v",86*/
{0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x0E,0x0A,0x0A,0x00,0x00},/*"w",87*/
{0x00,0x00,0x00,0x00,0x00,0x1B,0x0A,0x04,0x0A,0x1B,0x00,0x00},/*"x",88*/
{0x00,0x00,0x00,0x00,0x00,0x37,0x12,0x0A,0x0C,0x04,0x04,0x03},/*"y",89*/
{0x00,0x00,0x00,0x00,0x00,0x1E,0x08,0x04,0x04,0x1E,0x00,0x00},/*"z",90*/
{0x00,0x18,0x08,0x08,0x08,0x04,0x08,0x08,0x08,0x08,0x18,0x00},/*"{",91*/
{0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},/*"|",92*/
{0x00,0x06,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x06,0x00},/*"}",93*/
{0x02,0x25,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00} /*"~",94*/
};

#define SPI SPI1

#define CS_NUM  4
#define CS_BIT  (1<<CS_NUM)
#define CS_HIGH do { GPIOA->BSRR = GPIO_BSRR_BS_4; } while(0)
#define CS_LOW do { GPIOA->BSRR = GPIO_BSRR_BR_4; } while(0)
#define RESET_NUM 9
#define RESET_BIT (1<<RESET_NUM)
#define RESET_HIGH do { GPIOA->BSRR = GPIO_BSRR_BS_9; } while(0)
#define RESET_LOW  do { GPIOA->BSRR = GPIO_BSRR_BR_9; } while(0)
#define DC_NUM 8
#define DC_BIT (1<<DC_NUM)
#define DC_HIGH do { GPIOA->BSRR = GPIO_BSRR_BS_8; } while(0)
#define DC_LOW  do { GPIOA->BSRR = GPIO_BSRR_BR_8; } while(0)

// Set the CS pin low if val is non-zero.
// Note that when CS is being set high again, wait on SPI to not be busy.
static void oled_select(int val)
{
    if (val == 0) {
        while(SPI1->SR & SPI_SR_BSY);
        CS_HIGH;
    } else {
        while((GPIOA->ODR & (CS_BIT)) == 0) {
            ; // If CS is already low, this is an error.  Loop forever.
            // This has happened because something called a drawing subroutine
            // while one was already in process.  For instance, the main()
            // subroutine could call a long-running LCD_DrawABC function,
            // and an ISR interrupts it and calls another LCD_DrawXYZ function.
            // This is a common mistake made by students.
            // This is what catches the problem early.
        }
        CS_LOW;
    }
}

// If val is non-zero, set nRESET low to reset the display.
static void oled_reset(int val)
{
    if (val) {
        RESET_LOW;
    } else {
        RESET_HIGH;
    }
}

// If val is 1, select registers, otherwise select data
static void oled_reg_select(int val)
{
    if (val == 1) { // select registers
        DC_LOW; // clear
    } else { // select data
        DC_HIGH; // set
    }
}

void OLED_Reset(void)
{
    oleddev.reset(1);
    nano_wait(100000000);
    oleddev.reset(0);
    nano_wait(50000000); 
}

void OLED_WR_REG(uint8_t data) // CHECK THESE
{
    while((SPI->SR & SPI_SR_BSY) != 0); // ensure no other operation is running
    oleddev.reg_select(1); //DC goes to 0
    //*((volatile uint8_t*)&SPI->DR) = data; // write data to the data register
    SPI->DR = data;
    // NOTE: does this just send right away? 
}

void OLED_WR_DATA(uint8_t data)
{
    while((SPI->SR & SPI_SR_BSY) != 0); // ensure no other operation is running
    oleddev.reg_select(0); //DC goes to 1
    *((volatile uint8_t*)&SPI->DR) = data; // write data to the data register
    // NOTE: does this just send right away? 
}

// Prepare to write 16-bit data to the OLED
void OLED_WriteData16_Prepare()
{
    oleddev.reg_select(0); //ensure is in data mode
    SPI -> CR1 &= ~(SPI_CR1_SPE);
    SPI -> CR1 |= SPI_CR1_DFF; //config data frame to 16 bits
    SPI -> CR1 |= SPI_CR1_SPE; 
}

// Write 16-bit data
void OLED_WriteData16(u16 data)
{
    while((SPI->SR & SPI_SR_TXE) == 0); // wait if a transmission is happening
    SPI->DR = data; //set to data
}

// Finish writing 16-bit data
void OLED_WriteData16_End()
{
    SPI->CR1 &= ~SPI_CR1_DFF; // data frame back to 8 bits
}

// Set a register and write 8-bits (OR MORE) to it
void OLED_WriteRegMult(uint8_t OLED_Reg, uint16_t *OLED_RegValues, uint8_t NumRegs)
{
    OLED_WR_REG(OLED_Reg);
    for(int i = 0; i < NumRegs; i++)
    {
        OLED_WR_DATA(OLED_RegValues[0]);
    }
}

void OLED_WriteRegOnce(uint8_t OLED_Reg, uint16_t OLED_RegValue)
{
    OLED_WR_REG(OLED_Reg);
    OLED_WR_DATA(OLED_RegValue);
}

void OLED_WriteRAM_Prepare(void)
{
    OLED_WR_REG(oleddev.wramcmd);
}

void OLED_direction(uint8_t direction)
{
    oleddev.setxcmd = 0x15; // Col
    oleddev.setycmd = 0x75; // Row
    oleddev.wramcmd = 0x5C; // Ram W
    // switch(direction)
    // {
    //     case 0:
    //         oleddev.width = OLED_W;
    //         oleddev.height = OLED_H;
    //         OLED_WriteReg();
    // }
}

// Initalization sequence
void OLED_Init(void (*reset)(int), void (*select)(int), void(*reg_select)(int))
{
    oleddev.reset = oled_reset;
    oleddev.select = oled_select;
    oleddev.reg_select = oled_reg_select;
    if(reset)       {oleddev.reset = reset;}
    if(select)      {oleddev.select = select;}
    if(reg_select)  {oleddev.reg_select = reg_select;}
    oleddev.select(1); 
    OLED_Reset(); 

    //Init Sequenece for OLED SSD1351 - DOUBLE CHECK SOME OF THIS IF HAVING ISSUES (ref: https://github.com/afiskon/stm32-ssd1351/blob/master/Lib/ssd1351/ssd1351.c#L5)
    OLED_WriteRegOnce(0xFD, 0x12); // COMMANDLOCK - unlocks OLED driver
    OLED_WriteRegOnce(0xFD, 0xB1); // COMMANDLOCK - makes commands accessible
    OLED_WR_REG(0xAE); // SETSLEEPMODE - Set sleep mode ON, display OFF
    OLED_WriteRegOnce(0xB3, 0xF0); // CLKDIV - Reset is 1, set max refresh rate
    OLED_WriteRegOnce(0xCA, 0x7F); // MUXRATIO - set MUX ratio to default of 127
    OLED_WriteRegOnce(0xA0, 0x74); // SETREMAP - swaps color sequence (check this), scan dir, enable COM split
    uint16_t dataRowCol[] = {0x00, 0x7F}; // check this \/
    OLED_WriteRegMult(0x15, dataRowCol, sizeof(dataRowCol)); // SETCOL - sets to start of 0, end of 127
    OLED_WriteRegMult(0x75, dataRowCol, sizeof(dataRowCol)); // SETROW - sim ^, set strt 0, end 127
    OLED_WriteRegOnce(0xA1, 0x00); // STARTLINE - set to default value of 0
    OLED_WriteRegOnce(0xA2, 0x00); // DISPLAYOFFSET - set to 0
    OLED_WriteRegOnce(0xB5, 0x00); // SETGPIO - set GP0 and 1 to HiZ and input disabled
    OLED_WriteRegOnce(0xAB, 0x01); // FUNCTSEL - enable Vdd regulator, sel 8 bit para interface
    OLED_WriteRegOnce(0xB1, 0x32); // PRECHARGE -  phase 1 period of 5 DCLKS, phase 2 period of 3 DCLKS
    OLED_WriteRegOnce(0xBE, 0x05); // VCOMH - set to default of 0.82xVcc for COM deselt voltage
    OLED_WR_REG(0xA6); // DISPLAYMODE - set to normal display mode :D 
    uint16_t dataContrast[] = {0xFF, 0xFF, 0xFF};
    OLED_WriteRegMult(0xC1, dataContrast, sizeof(dataContrast)); // SETCONTRAST - sets the contrast of each color value
    OLED_WriteRegOnce(0xC7, 0x0F); // MASTERCONTRAST - default value
    // uint16_t dataSet[] = {0xA0, 0xB5, 0x55};
    // OLED_WriteRegMult(0xB4, dataSet, sizeof(dataSet)); // SETSVL - External VSL, reset hard coded from manual
    uint16_t dataEnhance[] = {0xA4, 0x00, 0x00};
    OLED_WriteRegMult(0xB2, dataEnhance, sizeof(dataEnhance)); // SETSVL - External VSL, reset hard coded from manual
    // OLED_WriteRegOnce(0xB6, 0x01); // PRECHARGE2 - set precharge period to to 1 DCLKS
    OLED_WR_REG(0xAF); // SETSLEEPMODE - Set sleep mode OFF, display ON 

    oleddev.setxcmd = 0x15; // Col
    oleddev.setycmd = 0x75; // Row
    oleddev.wramcmd = 0x5C; // Ram W
    oleddev.height = OLED_H;
    oleddev.width = OLED_W; 

    oleddev.select(0); 
}

void OLED_Setup()
{
    oled_reset(0);
    oled_select(0);
    oled_reg_select(0);
    OLED_Init(oled_reset, oled_select, oled_reg_select); 
}

// =========================================================================================
void OLED_SetWindow(uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd)
{
    OLED_WR_REG(oleddev.setxcmd);
    OLED_WR_DATA(xStart&0xFF);
    OLED_WR_DATA(xEnd&0xFF);

    OLED_WR_REG(oleddev.setycmd);
    OLED_WR_DATA(yStart&0xFF);
    OLED_WR_DATA(yEnd&0xFF);

    OLED_WR_REG(oleddev.wramcmd); // set to write to ram
}

// Set entire display to one color
void OLED_Clear(u16 Color)
{
    oleddev.select(1);
    unsigned int i,j;
    OLED_SetWindow(0,0,oleddev.width-1, oleddev.height-1);
    // OLED_WriteData16_Prepare();
    for(i=0; i<oleddev.height; i++)
    {
        for(j=0; j<oleddev.width; j++)
        {
            OLED_WR_DATA(Color & 0xFF);
            OLED_WR_DATA(Color >> 8);  
        }
    }
    // OLED_WriteData16_End();
    oleddev.select(0);
}

uint16_t make_color(uint8_t red, uint8_t green, uint8_t blue)
{
    uint16_t ret;
    ret = (red & 0xF8);
    ret |= ((green & 0xE0) >> 5) | ((green & 0x1C) << 11);
    ret |= (blue & 0xf8) << 5;

    return ret; 
}

void _OLED_DrawChar(u16 x, u16 y, u16 fc, u16 bc, char C, u8 size) // , u8 mode)
{
    u8 temp; 
    u8 pos, t; 
    C = C - ' '; //decremenet ASCII of character by 32 which is ' ' in ASCII
    OLED_SetWindow(x, y, (x+(size/2))-1, (y+size));
    for(pos = 0; pos < size+1; pos++)
    {
        if(size==12)
        {
            //temp = gsc_ssd1351_ascii_1206[(int)C][pos];
            temp = asc2_1206[(int)C][pos]; 
        }
        else if(size==16)
        {
            temp = gsc_ssd1351_ascii_1608[(int)C][pos];
        }
        else
        {
            temp = gsc_ssd1351_ascii_2412[(int)C][pos];
        }
        for(t = 0; t < (size/2); t++) // loop over each pixel of the byte
        {
            if(temp&0x01) // foreground
            {
                OLED_WR_DATA(fc & 0xFF);
                OLED_WR_DATA(fc >> 8);
            }
            else
            {
                OLED_WR_DATA(bc & 0xFF);
                OLED_WR_DATA(bc >> 8);
            }
            temp >>= 1; //shift temp by 1 bit
        }
    }   
}

void OLED_DrawChar(u16 x, u16 y, u16 fc, u16 bc, char C, u8 size) //, u8 mode)
{
    oleddev.select(1);
    _OLED_DrawChar(x, y, fc, bc, C, size);
    oleddev.select(0);
}

void OLED_DrawString(u16 x, u16 y, u16 fc, u16 bc, const char *S, u8 size) //, u8 mode)
{
    oleddev.select(1);
    while((*S<='~')&&(*S>=' '))
    {
        if(x > (oleddev.width-1) || y > (oleddev.height-1)) {return;}
        _OLED_DrawChar(x,y,fc,bc,*S,size);
        x += size/2; 
        S++; 
    }
    oleddev.select(0);
}

// const uint16_t arrow[7]={
//     0x0000,
//     0x0000,
//     0x0010,
//     0x0018,
//     0x001C,
//     0x1FFE,
//     0x1FFF
// };

void OLED_DrawArrow(u16 x0, u16 y0, u16 color)
{
    oleddev.select(1);
    OLED_SetWindow(x0, y0, x0+12, y0+12); // set 13x13 box
    uint16_t temp;
    // OLED_WR_DATA(fc & 0xFF);
    // OLED_WR_DATA(fc >> 8);
    for(u_int8_t i = 0; i < 13; i++)
    {
        if(i < 7) // lower half, mirrored image to save space
        {
            temp = arrow[i];
        }
        else
        {
            temp = arrow[12-i];
        }
        for(u_int8_t j = 0; j < 13; j++)
        {
            temp = temp >> 1;
            if(temp & 0x1)
            {
                OLED_WR_DATA(color & 0xFF);
                OLED_WR_DATA(color >> 8);
            }
            else
            {
                OLED_WR_DATA(BLACK & 0xFF);
                OLED_WR_DATA(BLACK >> 8); 
            }
        }
    }
    oleddev.select(0);
}